import numpy as np
import struct
import os
from pyproj import Proj, Transformer, CRS
from math import *

def calculate_utm_zone(longitude):
     """
     Calculate the UTM zone for a given longitude.
     """
     return int((longitude + 180) // 6) + 1

def write_binary_simple_ERF(output_binary, lat_erf, lon_erf, x_grid, y_grid, z_grid, point_data):

    x_grid = np.asarray(x_grid)
    y_grid = np.asarray(y_grid)
     # Ensure grids are consistent
    nrow, ncol = x_grid.shape
    nz = len(z_grid[0,0,:])

    #print(nrow, ncol)
    #print(x_grid[0,:])

    with open(output_binary, "wb") as file:
        file.write(struct.pack('iiii', ncol, nrow, nz, len(point_data)))

        for j in range(nrow):  # Iterate over the y-dimension
            for i in range(ncol):  # Iterate over the x-dimension
                file.write(struct.pack('f', lat_erf[i,j,0]))

        for j in range(nrow):  # Iterate over the y-dimension
            for i in range(ncol):  # Iterate over the x-dimension
                file.write(struct.pack('f', lon_erf[i,j,0]))


       # Write grid points using a nested for loop
        for i in range(ncol):
            x = x_grid[0, i]
            file.write(struct.pack('f', x))

        for j in range(nrow):
            y = y_grid[j, 0]
            file.write(struct.pack('f', y))

        for k in range(nz):
            zavg = np.mean(z_grid[:,:,k])
            file.write(struct.pack('f', zavg))

        # Write point data (if any)
        if point_data:
            for name, data in point_data.items():
                for k in range(nz):  # Iterate over the z-dimension
                    for j in range(nrow):  # Iterate over the y-dimension
                        for i in range(ncol):  # Iterate over the x-dimension
                            value = data[i, j, k]
                            file.write(struct.pack('f', value))


def write_binary_vtk_structured_grid(filename, x_grid, y_grid, z_grid,
                                     nz, k_to_delete, is_shift,
                                     point_data=None, velocity=None):
    """
    Writes a binary VTK file for a structured grid.

    Args:
    filename (str): Name of the VTK file to write.
    x_grid, y_grid, z_grid (numpy.ndarray): 3D arrays of grid coordinates.
    point_data (dict, optional): Dictionary of scalar data associated with the grid points.
    """

    x_grid = np.asarray(x_grid)
    y_grid = np.asarray(y_grid)
     # Ensure grids are consistent
    nx, ny = x_grid.shape
    nzval = nz - len(k_to_delete)

    print(nx, ny)

    with open(filename, 'wb') as f:
          # Write the VTK header
        f.write(b'# vtk DataFile Version 3.0\n')
        f.write(b'Generated by Python script\n')
        f.write(b'BINARY\n')
        f.write(b'DATASET STRUCTURED_GRID\n')
        f.write(f'DIMENSIONS {nx} {ny} {nzval}\n'.encode())
        f.write(f'POINTS {nx * ny * nzval} float\n'.encode())

        # Write grid points
        #points = np.stack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel()), axis=-1)
        #f.write(struct.pack('>' + 'f' * points.size, *points.ravel()))

        # Write grid points using a nested for loop
        for k in range(nz):
            z = np.mean(z_grid[:, :, nz-1-k])
            if nz-1-k in k_to_delete:
                print("Val is ", nz - 1 - k)
                continue;
            for j in range(ny):
                for i in range(nx):
                    x = x_grid[i, j]
                    y = y_grid[i, j]
                    f.write(struct.pack('>fff', x, y, z))


        # Write point data (if any)
        if point_data:
            f.write(f'POINT_DATA {nx * ny * nzval}\n'.encode())
            for name, data in point_data.items():
                if(name == "latitude" or name=="longitude"):
                    continue;
                f.write(f'SCALARS {name} float 1\n'.encode())
                f.write(b'LOOKUP_TABLE default\n')
                for k in range(nz):  # Iterate over the z-dimension
                    if nz-1-k in k_to_delete:
                        continue;
                    for j in range(ny):  # Iterate over the y-dimension
                        for i in range(nx):  # Iterate over the x-dimension
                            value = data[nx-1-i, j, nz-1-k]
                            f.write(struct.pack('>f', value))

            # Write velocity vector field
            if velocity is not None:
                f.write("VECTORS velocity float\n".encode())
                for k in range(nz):
                    if nz-1-k in k_to_delete:
                        continue;
                    for j in range(ny):
                        for i in range(nx):
                            vx, vy, vz = velocity[nx-1-i, j, nz-1-k]
                            f.write(struct.pack('>fff',vx, vy, vz))


def write_binary_vtk_cartesian_file(filename, x_grid, y_grid, z_grid,
                                    nz, k_to_delete, is_shift,
                                    point_data=None, velocity=None):
    """
    Writes a binary VTK file for a structured grid.

    Args:
    filename (str): Name of the VTK file to write.
    x_grid, y_grid, z_grid (numpy.ndarray): 3D arrays of grid coordinates.
    point_data (dict, optional): Dictionary of scalar data associated with the grid points.
    """

    x_grid = np.asarray(x_grid)
    y_grid = np.asarray(y_grid)
     # Ensure grids are consistent
    nrow, ncol = x_grid.shape
    nzval = nz

    print(ncol, nrow)

    with open(filename, 'wb') as f:
          # Write the VTK header
        f.write(b'# vtk DataFile Version 3.0\n')
        f.write(b'Generated by Python script\n')
        f.write(b'BINARY\n')
        f.write(b'DATASET STRUCTURED_GRID\n')
        f.write(f'DIMENSIONS {ncol} {nrow} {nzval}\n'.encode())
        f.write(f'POINTS {ncol * nrow * nzval} float\n'.encode())

        # Write grid points
        #points = np.stack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel()), axis=-1)
        #f.write(struct.pack('>' + 'f' * points.size, *points.ravel()))

        # Write grid points using a nested for loop
        for k in range(nz):
            z = np.mean(z_grid[:, :, k])
            for j in range(nrow):
                for i in range(ncol):
                    x = x_grid[j, i]
                    y = y_grid[j, i]
                    f.write(struct.pack('>fff', x, y, z))

        # Write point data (if any)
        if point_data:
            f.write(f'POINT_DATA {ncol * nrow * nzval}\n'.encode())
            for name, data in point_data.items():
                f.write(f'SCALARS {name} float 1\n'.encode())
                f.write(b'LOOKUP_TABLE default\n')
                for k in range(nz):  # Iterate over the z-dimension
                    for j in range(nrow):  # Iterate over the y-dimension
                        for i in range(ncol):  # Iterate over the x-dimension
                            value = data[i, j, k]
                            f.write(struct.pack('>f', value))


def find_latlon_indices(domain_lons, domain_lats, lon, lat):
    nlats = len(domain_lats)
    nlons = len(domain_lons)
    lat_idx = 0
    lon_idx = 0
    for i in range(0,nlats):
        if(lat < domain_lats[i]):
            lat_idx = i
            break

    for j in range(0,nlons):
        if(lon < domain_lons[j]):
            lon_idx = j
            break

    return lon_idx, lat_idx

def find_erf_domain_extents(x_grid, y_grid, nx, ny):

    # Need to determine the box extents of the cartesian box
    # (xmin, xmax), (y_min, y_max) that fits
    # in this region. Currently this method only works for the
    # northern hemisphere


    # Top is  [nx-1,:]
    # Bpttom is [0,:]
    # Left is [:,0]
    # Right is [:,ny-1]
    #print(x_grid[0,:])

    ymax = min(y_grid[nx-1,:]) - 100e3;
    #print("Value of ymin is ", ymax);

    # Intersect it with the leftmost longitude and
    # rightmost longitude

    # Leftmost longitude is the line joined by
    # x1,y1 = x_grid[0,-1], y_grid[0,-1]
    # x2, y2 = x_grid[nx-1,-1], y_grid[nx-1,-1]

    #print("Values are ", x_grid[0,-1], y_grid[0,-1], x_grid[-1,-1], y_grid[-1,-1])

    i1 = 0
    for i in range(0, nx-1):
        if(y_grid[i,-1] < ymax and y_grid[i+1,-1] > ymax):
            i1 = i
            break

    xmax = min(x_grid[i1,-1], x_grid[0,-1])    - 100e3

    for i in range(0, nx-1):
        if(y_grid[i,0] < ymax and y_grid[i+1,0] > ymax):
            i1 = i
            break
    xmin = max(x_grid[i1,0], x_grid[0,0]) + 100e3

    for i in range(0, ny-1):
        if(x_grid[0,i] < xmax and x_grid[0,i+1] > xmax):
            i1 = i
            break
    y1 = y_grid[0,i1];

    for i in range(0, ny-1):
        if(x_grid[0,i] < xmin and x_grid[0,i+1] > xmin):
            i1 = i
            break

    y2 = y_grid[0,i1]

    ymin = max(y1,y2) + 100e3

    filename = "Output/domain_extents.txt"

    try:
        # Use exclusive creation mode ("x") so only one rank succeeds
        with open(filename, "x") as f:
            print("geometry.prob_lo  =",
                   np.ceil(xmin + 50e3),
                   np.ceil(ymin + 50e3),
                   0.0,
                   file=f)
            print("geometry.prob_hi  =",
                   np.floor(xmax - 50e3),
                   np.floor(ymax - 50e3),
                   25000.0,
                   file=f)
    except FileExistsError:
        # Another rank already wrote the file â€” just skip
        pass

    return xmin, xmax, ymin, ymax


def write_binary_vtk_cartesian(date_time_forecast_str, output_binary, domain_lats, domain_lons,
                               x_grid, y_grid, z_grid, nx, ny, nz,
                               k_to_delete, lambert_conformal, point_data=None):



    xmin, xmax, ymin, ymax = find_erf_domain_extents(x_grid, y_grid, nx, ny)
    #print("xmin, xmax, ymin, ymax are ", xmin, xmax, ymin, ymax);


    print("Value of nx and ny are ", nx, ny)

    nx_erf = ny
    ny_erf = nx
    nz_erf= nz - len(k_to_delete) + 1
    dx = (xmax - xmin)/(nx_erf-1)
    dy = (ymax - ymin)/(ny_erf-1)

    xvec_erf = np.zeros(nx_erf)
    yvec_erf = np.zeros(ny_erf)
    for i in range(nx_erf):
        xvec_erf[i] = xmin + dx*i

    for j in range(ny_erf):
        yvec_erf[j] = ymin + dy*j

    x_grid_erf, y_grid_erf = np.meshgrid(xvec_erf, yvec_erf)
    z_grid_erf = np.zeros((nx_erf, ny_erf, nz_erf))

    rho_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    temp_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    uvel_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    vvel_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    wvel_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    rh_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    theta_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    qv_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    qc_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    qr_erf = np.zeros((nx_erf, ny_erf, nz_erf))
    theta_erf = np.zeros((nx_erf, ny_erf, nz_erf))

    lat_erf = np.zeros((nx_erf,ny_erf,nz_erf))    
    lon_erf = np.zeros((nx_erf,ny_erf,nz_erf))

    scalars = {
         "density": rho_erf,
         "uvel": uvel_erf,
         "vvel": vvel_erf,
         "wvel": wvel_erf,
         "theta": theta_erf,
         "qv": qv_erf,
         "qc": qc_erf,
         "qr": qr_erf,
    }

    scalars_to_plot = {
         "latitude": lat_erf,
         "longitude": lon_erf,
         "density": rho_erf,
         "uvel": uvel_erf,
         "vvel": vvel_erf,
         "wvel": wvel_erf,
         "theta": theta_erf,
         "qv": qv_erf,
         "qc": qc_erf,
         "qr": qr_erf,
    }


    kcount = 1
    for k in range(nz):  # Iterate over the z-dimension
        if nz-1-k in k_to_delete:
            continue
        z_grid_erf[:,:,kcount] = np.mean(z_grid[:,:,nz-1-k])
        kcount = kcount+1
    z_grid_erf[:,:,0] = 0.0


    #lambert_conformal = CRS.from_proj4(
    #"+proj=lcc +lat_1=30 +lat_2=60 +lat_0=38.5 +lon_0=-97 +datum=WGS84 +units=m +no_defs")

    transformer = Transformer.from_crs(lambert_conformal, "EPSG:4326", always_xy=True)

    uvel_3d = point_data["uvel"]
    vvel_3d = point_data["vvel"]

    
    print("Values of nx_erf and ny_erf are", nx_erf, ny_erf);
    print("Shapes of xgrid and ygrid are", x_grid.shape, y_grid.shape);
    print("Shapes of xgrid_erf and ygrid_erf are", x_grid_erf.shape, y_grid_erf.shape);

    x1 = 0.0
    y1 = 0.0
    x2 = 0.0
    y2 = 0.0

    if point_data:
        for name, data in point_data.items():
            if name in scalars_to_plot:  # Check if the name exists in the scalars dictionary

                if data is None:
                    print(f"name is {name}, but data is None")
                else:
                    print("name is", name)
                    print("size is", data.shape)
                for j in range(ny_erf):
                    for i in range(nx_erf):
                        lon, lat = transformer.transform(x_grid_erf[j,i], y_grid_erf[j,i])
                        lon_idx, lat_idx = find_latlon_indices(domain_lons, domain_lats, lon, lat)
                        lat_erf[i,j,0] = lat;
                        lon_erf[i,j,0] = lon;

                        lat0 = domain_lats[lat_idx-1]
                        lat1 = domain_lats[lat_idx]
                        lon0 = domain_lons[lon_idx-1]
                        lon1 = domain_lons[lon_idx]     
            
                        # fractional distances
                        fx = (lon - lon0) / (lon1 - lon0)
                        fy = (lat - lat0) / (lat1 - lat0)

                    
                        if(i < nx_erf-1):
                            x1 = x_grid[j,i]
                            y1 = y_grid[j,i]
                    
                            x2 = x_grid[j,i+1]
                            y2 = y_grid[j,i+1]
                        elif(i == nx_erf-1):
                            x1 = x_grid[j,i-1]
                            y1 = y_grid[j,i-1]
                
                            x2 = x_grid[j,i]
                            y2 = y_grid[j,i]

                        theta = atan2(y2-y1, x2-x1)                    
                            
                        #print("theta is ", x1, x2, y1, y2, theta)

                        kcount = 1
                        for k in range(nz):  # Iterate over the z-dimension
                            if nz-1-k in k_to_delete:
                                continue
                            if(name == "latitude"):
                                scalars_to_plot[name][i,j,kcount] = lat;
                                #print("Reaching here lat", lat)
                            elif(name == "longitude"):
                                scalars_to_plot[name][i,j,kcount] = lon;    
                                #print("Reaching here lon", lon)
                            elif(name == "uvel" or name == "vvel"):
                                u_tmp = (fx*fy*uvel_3d[nx-1-lat_idx, lon_idx, nz-1-k] + fx*(1-fy)*uvel_3d[nx-1-lat_idx, lon_idx-1, nz-1-k] +
                                                         (1-fx)*(1-fy)*uvel_3d[nx-1-lat_idx+1, lon_idx-1, nz-1-k] + (1-fx)*fy*uvel_3d[nx-1-lat_idx+1, lon_idx, nz-1-k])
                                v_tmp = (fx*fy*vvel_3d[nx-1-lat_idx, lon_idx, nz-1-k] + fx*(1-fy)*vvel_3d[nx-1-lat_idx, lon_idx-1, nz-1-k] +
                                                         (1-fx)*(1-fy)*vvel_3d[nx-1-lat_idx+1, lon_idx-1, nz-1-k] + (1-fx)*fy*vvel_3d[nx-1-lat_idx+1, lon_idx, nz-1-k])
                          
                                if(name == "uvel"):
                                    scalars_to_plot[name][i,j,kcount] = u_tmp*cos(theta) - v_tmp*sin(theta)
                                elif(name == "vvel"):
                                    scalars_to_plot[name][i,j,kcount] = u_tmp*sin(theta) + v_tmp*cos(theta)  
                            else:
                                scalars_to_plot[name][i,j,kcount] = (fx*fy*data[nx-1-lat_idx, lon_idx, nz-1-k] + fx*(1-fy)*data[nx-1-lat_idx, lon_idx-1, nz-1-k] +
                                                         (1-fx)*(1-fy)*data[nx-1-lat_idx+1, lon_idx-1, nz-1-k] + (1-fx)*fy*data[nx-1-lat_idx+1, lon_idx, nz-1-k])

                            if(name != "latitude" and name != "longitude"):
                                scalars[name][i,j,kcount] = scalars_to_plot[name][i,j,kcount]

                            kcount = kcount+1

                        scalars_to_plot[name][i,j,0] = scalars_to_plot[name][i,j,1]
                        if(name != "latitude" and name != "longitude"):
                            scalars[name][i,j,0] = scalars[name][i,j,1]
                                
            else:
                print("Variable not found in scalars list", name)
                #sys.exit()
    output_cart_vtk = "./Output/VTK/3D/ERFDomain/" + "ERF_IC_" + date_time_forecast_str +".vtk"

    tmp = []
    print("Writing write_binary_vtk_cartesian_file")
    write_binary_vtk_cartesian_file(output_cart_vtk, x_grid_erf, y_grid_erf, z_grid_erf, nz_erf, tmp, False, scalars_to_plot)
    print("Writing write_binary_simple_ERF")
    write_binary_simple_ERF(output_binary, lat_erf, lon_erf, x_grid_erf, y_grid_erf, z_grid_erf, scalars)
